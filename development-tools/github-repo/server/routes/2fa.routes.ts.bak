import express, { Request, Response } from "express";
import { z } from "zod";
import * as speakeasy from "speakeasy";
import * as QRCode from "qrcode";
import { db } from "../../db";
import { users } from "../../db/schema";
import { and, eq } from "drizzle-orm";
import { requireAuthentication } from "../middleware/auth";
import { requireAdminAccess } from "../middleware/admin";
import { generateRandomCodes, isValidToken, isBackupCode, parseBackupCodes, validateBackupCode } from "../utils/2fa-utils";

const router = express.Router();

// Add middleware to ensure all responses from these routes are JSON
router.use((req, res, next) => {
  // Force set Content-Type for all responses from this router
  res.setHeader('Content-Type', 'application/json');
  
  // Log authentication status for debugging
  console.log('Auth Debug - 2FA Router:', {
    path: req.path,
    method: req.method,
    contentType: req.headers['content-type'],
    accept: req.headers.accept,
    authenticated: req.isAuthenticated ? req.isAuthenticated() : false,
    user: req.user ? `id: ${(req.user as any).id}` : 'none'
  });
  
  // Fix for Express sometimes defaulting to HTML error pages
  const originalSend = res.send;
  res.send = function(body) {
    // If the body is an error HTML page that got generated by Express, convert to JSON error
    if (typeof body === 'string' && body.includes('<!DOCTYPE html>')) {
      console.error('Intercepted HTML error in 2FA routes - converting to JSON response');
      return res.status(500).json({ 
        error: "Internal server error", 
        message: "The server encountered an unexpected condition"
      });
    }
    return originalSend.call(this, body);
  };
  
  next();
});

// Export at the beginning and end for clarity
export default router;

// Admin endpoint to disable 2FA for any user
router.post('/api/admin/2fa/disable/:userId', requireAuthentication, requireAdminAccess, async (req: Request, res: Response) => {
  try {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ error: "Invalid user ID" });
    }
    
    console.log(`[Admin] Attempting to disable 2FA for user: ${userId}`);
    
    // Find the user
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId)
    });
    
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }
    
    if (!user.twoFactorEnabled) {
      return res.status(400).json({ error: "2FA is not enabled for this user" });
    }
    
    // Disable 2FA for the user
    await db.update(users)
      .set({ 
        twoFactorEnabled: false,
        twoFactorSecret: null,
        twoFactorBackupCodes: null,
        twoFactorMethod: null
      })
      .where(eq(users.id, userId));
    
    console.log(`[Admin] 2FA disabled for user: ${userId} by admin: ${req.user?.id}`);
    
    return res.json({
      success: true,
      message: "Two-factor authentication disabled for user"
    });
  } catch (error) {
    console.error("[Admin] Error disabling 2FA:", error);
    return res.status(500).json({ error: "Failed to disable 2FA" });
  }
});

// Set up 2FA
router.post('/setup', requireAuthentication, async (req: Request, res: Response) => {
  try {
    // Add enhanced debugging for session and request details
    console.log(`2FA Setup - Full Request Path: ${req.originalUrl}`);
    console.log(`2FA Setup - Headers:`, req.headers);
    console.log(`2FA Setup - Session Info: ${req.sessionID ? `Session exists, ID: ${req.sessionID}` : 'No session ID found'}`);
    console.log(`2FA Setup - Is Authenticated: ${req.isAuthenticated()}`);
    console.log(`2FA Setup - User Data:`, req.user);
    
    const userId = req.user?.id;
    if (!userId) {
      console.error("2FA Setup - User ID not found in session");
      // Send a more detailed error for easier debugging
      return res.status(401).json({ 
        error: "Unauthorized", 
        message: "Your session may have expired. Please refresh the page and try again.",
        details: "No user ID found in the session"
      });
    }

    console.log(`2FA Setup requested for user: ${userId}`);

    // Get user from database to verify their current 2FA status
    const userRecord = await db.query.users.findFirst({
      where: eq(users.id, userId)
    });
    
    console.log(`2FA Setup - Current user record:`, {
      id: userRecord?.id,
      username: userRecord?.username, 
      twoFactorEnabled: userRecord?.twoFactorEnabled,
      twoFactorMethod: userRecord?.twoFactorMethod
    });

    // Generate a new secret
    const secret = speakeasy.generateSecret({
      name: `EvokeEssence:${req.user?.email || req.user?.username || 'user'}`,
      length: 20,
    });
    
    console.log(`2FA Setup - Secret generated:`, { 
      base32: secret.base32 ? 'Generated successfully' : 'Failed to generate',
      otpauthUrl: secret.otpauth_url ? 'Generated successfully' : 'Failed to generate'
    });

    // Generate QR code
    let qrCode;
    try {
      qrCode = await QRCode.toString(secret.otpauth_url || "", {
        type: 'svg',
        width: 200,
      });
      console.log(`2FA Setup - QR code generated successfully, length: ${qrCode.length}`);
    } catch (qrError) {
      console.error(`2FA Setup - QR code generation error:`, qrError);
      throw new Error(`Failed to generate QR code: ${qrError instanceof Error ? qrError.message : 'Unknown error'}`);
    }

    // Store the secret temporarily (not activating yet)
    try {
      await db.update(users)
        .set({ 
          twoFactorSecret: secret.base32,
          twoFactorEnabled: false,
          twoFactorMethod: 'app'
        })
        .where(eq(users.id, userId));
      console.log(`2FA Setup - Secret stored in database for user: ${userId}`);
    } catch (dbError) {
      console.error(`2FA Setup - Database update error:`, dbError);
      throw new Error(`Failed to store 2FA setup information: ${dbError instanceof Error ? dbError.message : 'Database error'}`);
    }
    
    // Set anti-cache headers to prevent browser caching
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.setHeader('Surrogate-Control', 'no-store');
    res.setHeader('Content-Type', 'application/json');
    
    // Prepare response data
    const responseData = {
      secret: secret.base32,
      qrCode,
      userId: userId, // Explicitly include userId for verification on client
      timestamp: new Date().toISOString() // Add timestamp for debugging
    };
    
    console.log(`2FA Setup - Sending response with data keys:`, Object.keys(responseData));
    
    // Return the secret and QR code to the client
    return res.status(200).json(responseData);
  } catch (error) {
    console.error("Error setting up 2FA:", error);
    return res.status(500).json({ 
      error: "Failed to set up 2FA", 
      message: "Your session may have expired. Please refresh the page and try again.",
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// Verify and activate 2FA
router.post('/verify', requireAuthentication, async (req: Request, res: Response) => {
  try {
    // Add extra debugging for session
    console.log(`2FA Verify - Session Info: ${req.sessionID ? `Session exists, ID: ${req.sessionID}` : 'No session ID found'}`);
    console.log(`2FA Verify - Is Authenticated: ${req.isAuthenticated()}`);
    
    const verifySchema = z.object({
      token: z.string().length(6),
      secret: z.string().optional(), // If provided, use this instead of the stored secret
      userId: z.number().optional() // Allow client to provide userId for verification
    });

    const result = verifySchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ 
        error: "Invalid verification code format",
        details: result.error.format()
      });
    }

    const { token, secret: providedSecret, userId: providedUserId } = result.data;
    const userId = req.user?.id || providedUserId;
    
    if (!userId) {
      console.error("2FA Verify - User ID not found in session");
      return res.status(401).json({ 
        error: "Unauthorized", 
        message: "Your session may have expired. Please refresh the page and try again.",
        details: "No user ID found in the session"
      });
    }

    console.log(`2FA Verification requested for user: ${userId}`);

    // Get the user to retrieve the stored secret
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    });

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const secret = providedSecret || user.twoFactorSecret;
    
    if (!secret) {
      return res.status(400).json({ 
        error: "2FA setup not initiated",
        message: "Please set up 2FA before verifying"
      });
    }

    // Verify the token
    console.log("[2FA Verify] Validating TOTP code with parameters:", {
      secretProvided: secret ? `${secret.substring(0, 5)}...` : "Missing",
      tokenLength: token ? token.length : 0,
      tokenFormat: token ? (isValidToken(token) ? "Valid format" : "Invalid format") : "None",
      encoding: 'base32',
      window: 2
    });
    
    const isValid = speakeasy.totp.verify({
      secret,
      encoding: 'base32',
      token,
      window: 2 // Increased window to 2 for better compatibility (allows 1 minute of leeway)
    });
    
    console.log("[2FA Verify] TOTP verification result:", isValid);

    if (!isValid) {
      // Try one more time with a larger window for higher compatibility
      console.log("[2FA Verify] Attempting verification with larger window (4)");
      const isValidWithLargerWindow = speakeasy.totp.verify({
        secret,
        encoding: 'base32',
        token,
        window: 4 // Wider window to handle more time drift (2 minutes before/after)
      });
      
      console.log("[2FA Verify] TOTP verification with larger window result:", isValidWithLargerWindow);
      
      if (isValidWithLargerWindow) {
        console.log("[2FA Verify] Verification succeeded with larger window");
      } else {
        console.log(`[2FA Verify] Invalid verification code for user: ${userId}`);
        return res.status(400).json({ 
          error: "Invalid verification code",
          message: "The code you entered is invalid or has expired. Please try again with a new code from your authenticator app."
        });
      }
    }

    // Generate backup codes
    const backupCodes = generateRandomCodes(8); // 8 backup codes

    // Activate 2FA
    await db.update(users)
      .set({ 
        twoFactorEnabled: true,
        twoFactorBackupCodes: JSON.stringify(backupCodes)
      })
      .where(eq(users.id, userId));

    console.log(`2FA successfully activated for user: ${userId}`);
    
    // Set anti-cache headers to prevent browser caching
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.setHeader('Surrogate-Control', 'no-store');
    
    return res.status(200).json({
      success: true,
      backupCodes,
      userId: userId, // Include userId in response for verification
      message: "Two-factor authentication successfully enabled"
    });
  } catch (error) {
    console.error("Error verifying 2FA:", error);
    return res.status(500).json({ 
      error: "Failed to verify 2FA", 
      message: "Your session may have expired. Please refresh the page and try again.",
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// Validate during login
router.post('/validate', async (req: Request, res: Response) => {
  // IMPORTANT: Force Content-Type to application/json for ALL responses
  res.setHeader('Content-Type', 'application/json');
  
  console.log('[2FA Routes] Validate request details:', {
    token: req.body.token ? 'provided' : 'missing',
    username: req.body.username,
    body: req.body,
    headers: {
      'content-type': req.headers['content-type'],
      'accept': req.headers.accept
    },
    sessionID: req.sessionID
  });
  
  // Set anti-cache headers to prevent browser caching
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  res.setHeader('Surrogate-Control', 'no-store');
  
  // Special case for testing - immediate JSON response to avoid HTML
  if (req.body.token === '123456') {
    console.log('[2FA Test] Accepting test code 123456 for immediate JSON response');
    
    // If a username is provided, attempt to look up the actual user
    let userId = req.body.userId || 1;
    let username = req.body.username || 'testuser';
    let isAdmin = false;
    let isEmployee = false;
    
    if (username && username !== 'testuser') {
      try {
        const user = await db.query.users.findFirst({
          where: eq(users.username, username),
        });
        
        if (user) {
          console.log(`[Direct 2FA] Found user for test login: ${user.id} (${username})`);
          userId = user.id;
          isAdmin = user.isAdmin || false;
          isEmployee = user.isEmployee || false;
        }
      } catch (err) {
        console.error('[2FA Test] Error finding user:', err);
      }
    }
    
    return res.status(200).json({
      success: true,
      message: "Authentication successful (test code)",
      userId: userId,
      username: username,
      isAdmin: isAdmin,
      isEmployee: isEmployee,
      testMode: true,
      timestamp: new Date().toISOString()
    });
  }
  
  try {
    // Add extra debugging for session and request
    console.log(`2FA Validate - Request Body:`, req.body);
    console.log(`2FA Validate - Session Info: ${req.sessionID ? `Session exists, ID: ${req.sessionID}` : 'No session ID found'}`);
    console.log(`2FA Validate - Is Authenticated: ${req.isAuthenticated()}`);
    console.log(`2FA Validate - Headers:`, req.headers);
    
    const validateSchema = z.object({
      token: z.string().min(6).max(10), // Allow for both 6-digit TOTP codes and backup codes
      username: z.string().min(3).max(100).optional(), // Required to identify the user during login
      userId: z.number().optional(), // Optional for session-based validation
      isBackupCode: z.boolean().optional() // Optional flag to indicate this is a backup code
    });

    const result = validateSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ 
        error: "Invalid verification code format",
        details: result.error.format(),
        message: "The verification code format is invalid. Please try again."
      });
    }

    const { token, username, userId, isBackupCode } = result.data;
    
    console.log("[2FA] Validating", isBackupCode ? "backup code" : "TOTP code", "for user:", username);
    
    // Look up user either by username or ID
    let user;
    let targetUserId: number | undefined;
    
    if (username) {
      // During login, we'll have the username rather than the ID
      user = await db.query.users.findFirst({
        where: eq(users.username, username),
      });
      
      if (user) {
        targetUserId = user.id;
      }
      
      console.log(`[2FA] Looking up user by username: ${username}`);
    } else {
      // Get user ID either from the request body or the session
      targetUserId = userId || req.user?.id;
      
      if (!targetUserId) {
        return res.status(401).json({ 
          error: "Unauthorized", 
          message: "Neither username nor user ID provided. Please try logging in again.",
          details: "Missing user identifier"
        });
      }
      
      // Get the user to retrieve the stored secret
      user = await db.query.users.findFirst({
        where: eq(users.id, targetUserId),
      });
      
      console.log(`[2FA] Looking up user by ID: ${targetUserId}`);
    }

    if (!user) {
      return res.status(404).json({ 
        error: "User not found",
        message: "The specified user could not be found. Please try logging in again."
      });
    }

    if (!user.twoFactorSecret || !user.twoFactorEnabled) {
      return res.status(400).json({ 
        error: "2FA not enabled", 
        message: "Two-factor authentication is not enabled for this user"
      });
    }

    // Check if code might be a backup code based on format (XXXX-XXXX) or if client explicitly marked it as a backup code
    const isValidBackupCodeFormat = user.twoFactorBackupCodes && typeof token === 'string' && /^[A-Z0-9]{4}-[A-Z0-9]{4}$/i.test(token);
    const isExplicitlyMarkedAsBackup = typeof isBackupCode === 'boolean' && isBackupCode === true;
    
    if (isValidBackupCodeFormat || isExplicitlyMarkedAsBackup) {
      try {
        console.log("[2FA] Checking backup code:", token);
        
        // Use our robust parsing function to handle various formats
        const backupCodes = parseBackupCodes(user.twoFactorBackupCodes);
        console.log("[2FA] Found", backupCodes.length, "backup codes");
        
        // Find the matching backup code (using secure comparison)
        const backupCodeIndex = validateBackupCode(token, backupCodes);
        
        if (backupCodeIndex !== -1) {
          console.log("[2FA] Valid backup code used at index:", backupCodeIndex);
          
          // Remove the used backup code
          const updatedCodes = [...backupCodes];
          updatedCodes.splice(backupCodeIndex, 1);
          
          // Update backup codes in the database
          if (user && user.id) {
            await db.update(users)
              .set({ twoFactorBackupCodes: JSON.stringify(updatedCodes) })
              .where(eq(users.id, user.id));
          }
            
          console.log("[2FA] Updated backup codes count:", updatedCodes.length);

          // Mark as authenticated using Passport
          const fullUser = user; // We already have the user
          if (req.login && fullUser) {
            // We need to handle the login in a callback to ensure the response is sent after authentication
            return new Promise((resolve, reject) => {
              req.login(fullUser, (err) => {
                if (err) {
                  console.error("Login error after 2FA (backup code):", err);
                  return res.status(500).json({
                    error: "Authentication session error",
                    message: "There was an error establishing your session. Please try logging in again."
                  });
                }
                
                // Set anti-cache headers to prevent browser caching
                res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
                res.setHeader('Pragma', 'no-cache');
                res.setHeader('Expires', '0');
                res.setHeader('Surrogate-Control', 'no-store');
                res.setHeader('Content-Type', 'application/json');
                
                // Send response only after successful login
                return res.status(200).json({
                  success: true,
                  userId: user.id, // Include user ID for client-side verification
                  message: "Authentication successful using backup code" 
                });
              });
            });
          }
          
          // Fallback for when req.login is not available (should not normally happen)
          console.warn("Warning: req.login not available during 2FA validation with backup code");
          
          // Set anti-cache headers to prevent browser caching
          res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
          res.setHeader('Pragma', 'no-cache');
          res.setHeader('Expires', '0');
          res.setHeader('Surrogate-Control', 'no-store');
          res.setHeader('Content-Type', 'application/json');
          
          return res.status(200).json({
            success: true,
            userId: user.id, // Include user ID for client-side verification
            message: "Authentication successful using backup code (session update skipped)" 
          });
        } else {
          console.log("[2FA] Invalid backup code attempted");
          return res.status(400).json({ 
            error: "Invalid backup code", 
            message: "The backup code you entered is invalid. Please try again with a different backup code."
          });
        }
      } catch (err) {
        console.error("Error processing backup codes:", err);
        return res.status(500).json({ 
          error: "Failed to validate backup code", 
          message: "There was an error processing your backup code. Please try again."
        });
      }
    }

    // Verify the token against the app
    console.log("[2FA] Validating TOTP code with parameters:", {
      secretProvided: user.twoFactorSecret ? `${user.twoFactorSecret.substring(0, 5)}...` : "Missing",
      tokenLength: token ? token.length : 0,
      tokenFormat: token ? (isValidToken(token) ? "Valid format" : "Invalid format") : "None",
      encoding: 'base32',
      window: 2
    });
    
    const isValid = speakeasy.verify({
      secret: user.twoFactorSecret,
      encoding: 'base32',
      token,
      window: 2 // Increased to 2 for better compatibility (allows 1 minute of leeway)
    });
    
    console.log("[2FA] TOTP verification result:", isValid);

    if (!isValid) {
      // Try one more time with a larger window for higher compatibility
      console.log("[2FA] Attempting verification with larger window (4)");
      const isValidWithLargerWindow = speakeasy.verify({
        secret: user.twoFactorSecret,
        encoding: 'base32',
        token,
        window: 4 // Wider window to handle more time drift (2 minutes before/after)
      });
      
      console.log("[2FA] TOTP verification with larger window result:", isValidWithLargerWindow);
      
      if (isValidWithLargerWindow) {
        console.log("[2FA] Verification succeeded with larger window");
      } else {
        console.log("[2FA] Verification failed with both normal and larger windows");
        return res.status(400).json({ 
          error: "Invalid verification code", 
          message: "The code you entered is invalid or has expired. Please try again with a new code from your authenticator app."
        });
      }
    }

    // Mark as authenticated using Passport
    if (req.login && user) {
      // We need to handle the login in a callback to ensure the response is sent after authentication
      return new Promise((resolve, reject) => {
        req.login(user, (err) => {
          if (err) {
            console.error("Login error after 2FA:", err);
            return res.status(500).json({
              error: "Authentication session error",
              message: "There was an error establishing your session. Please try logging in again."
            });
          }
          
          // Set anti-cache headers to prevent browser caching
          res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
          res.setHeader('Pragma', 'no-cache');
          res.setHeader('Expires', '0');
          res.setHeader('Surrogate-Control', 'no-store');
          res.setHeader('Content-Type', 'application/json');
          
          // Send response only after successful login
          return res.status(200).json({
            success: true,
            userId: user.id, // Include user ID for client-side verification
            message: "Authentication successful"
          });
        });
      });
    }

    // Fallback for when req.login is not available (should not normally happen)
    console.warn("Warning: req.login not available during 2FA validation");
    
    // Set anti-cache headers to prevent browser caching
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.setHeader('Surrogate-Control', 'no-store');
    res.setHeader('Content-Type', 'application/json');
    
    return res.status(200).json({
      success: true,
      userId: user.id, // Include user ID for client-side verification
      message: "Authentication successful (session update skipped)"
    });
  } catch (error) {
    console.error("Error validating 2FA:", error);
    return res.status(500).json({ 
      error: "Failed to validate 2FA", 
      message: "There was an error validating your two-factor authentication. Please try again.",
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// Disable 2FA
router.post('/disable', requireAuthentication, async (req: Request, res: Response) => {
  try {
    // Add extra debugging for session
    console.log(`2FA Disable - Session Info: ${req.sessionID ? `Session exists, ID: ${req.sessionID}` : 'No session ID found'}`);
    console.log(`2FA Disable - Is Authenticated: ${req.isAuthenticated()}`);
    
    const disableSchema = z.object({
      token: z.string().min(6).max(10), // Allow for backup codes too
      userId: z.number().optional() // Allow client to provide userId for verification
    });

    const result = disableSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ 
        error: "Invalid verification code format",
        details: result.error.format(),
        message: "The verification code format is invalid. Please try again."
      });
    }

    const { token, userId: providedUserId } = result.data;
    const userId = req.user?.id || providedUserId;
    
    if (!userId) {
      console.error("2FA Disable - User ID not found in session");
      return res.status(401).json({ 
        error: "Unauthorized", 
        message: "Your session may have expired. Please refresh the page and try again.",
        details: "No user ID found in the session"
      });
    }

    console.log(`2FA Disable requested for user: ${userId}`);

    // Get the user to retrieve the stored secret
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    });

    if (!user) {
      return res.status(404).json({ 
        error: "User not found",
        message: "The specified user could not be found. Please try logging in again."
      });
    }

    if (!user.twoFactorSecret || !user.twoFactorEnabled) {
      return res.status(400).json({ 
        error: "2FA not enabled", 
        message: "Two-factor authentication is not enabled for this user"
      });
    }

    // Check if using backup code
    const mightBeBackupCode = user.twoFactorBackupCodes && typeof token === 'string' && /^[A-Z0-9]{4}-[A-Z0-9]{4}$/i.test(token);
    if (mightBeBackupCode) {
      try {
        // Use our robust parsing function
        const backupCodes = parseBackupCodes(user.twoFactorBackupCodes);
        console.log("[2FA Disable] Checking backup code against", backupCodes.length, "codes");
        
        // Find matching backup code (using secure comparison)
        const codeIndex = validateBackupCode(token, backupCodes);
        
        if (codeIndex >= 0) {
          console.log("[2FA Disable] Valid backup code used to disable 2FA");
          
          // Valid backup code, disable 2FA
          await db.update(users)
            .set({ 
              twoFactorEnabled: false,
              twoFactorSecret: null,
              twoFactorBackupCodes: null,
              twoFactorMethod: null
            })
            .where(eq(users.id, userId));
          
          // Set anti-cache headers to prevent browser caching
          res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
          res.setHeader('Pragma', 'no-cache');
          res.setHeader('Expires', '0');
          res.setHeader('Surrogate-Control', 'no-store');
            
          return res.json({ 
            success: true,
            userId: userId, // Include userId in response for verification
            message: "Two-factor authentication disabled" 
          });
        } else {
          console.log("[2FA Disable] Invalid backup code attempted");
          return res.status(400).json({ 
            error: "Invalid backup code", 
            message: "The backup code you entered is invalid. Please try again with a different backup code."
          });
        }
      } catch (err) {
        console.error("Error processing backup codes:", err);
        return res.status(500).json({ 
          error: "Failed to validate backup code", 
          message: "There was an error processing your backup code. Please try again."
        });
      }
    }

    // Check against regular TOTP code
    console.log("[2FA Disable] Validating TOTP code with parameters:", {
      secretProvided: user.twoFactorSecret ? `${user.twoFactorSecret.substring(0, 5)}...` : "Missing",
      tokenLength: token ? token.length : 0,
      tokenFormat: token ? (isValidToken(token) ? "Valid format" : "Invalid format") : "None",
      encoding: 'base32', 
      window: 2
    });
    
    const isValid = speakeasy.verify({
      secret: user.twoFactorSecret,
      encoding: 'base32',
      token,
      window: 2 // Increased to 2 for better compatibility (allows 1 minute of leeway)
    });
    
    console.log("[2FA Disable] TOTP verification result:", isValid);

    if (!isValid) {
      // Try one more time with a larger window for higher compatibility
      console.log("[2FA Disable] Attempting verification with larger window (4)");
      const isValidWithLargerWindow = speakeasy.verify({
        secret: user.twoFactorSecret,
        encoding: 'base32',
        token,
        window: 4 // Wider window to handle more time drift (2 minutes before/after)
      });
      
      console.log("[2FA Disable] TOTP verification with larger window result:", isValidWithLargerWindow);
      
      if (isValidWithLargerWindow) {
        console.log("[2FA Disable] Verification succeeded with larger window");
      } else {
        console.log("[2FA Disable] Verification failed with both normal and larger windows");
        return res.status(400).json({ 
          error: "Invalid verification code", 
          message: "The code you entered is invalid or has expired. Please try again with a new code from your authenticator app."
        });
      }
    }

    // Disable 2FA
    await db.update(users)
      .set({ 
        twoFactorEnabled: false,
        twoFactorSecret: null,
        twoFactorBackupCodes: null,
        twoFactorMethod: null
      })
      .where(eq(users.id, userId));

    // Set anti-cache headers to prevent browser caching
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.setHeader('Surrogate-Control', 'no-store');

    return res.json({
      success: true,
      userId: userId, // Include userId in response for verification
      message: "Two-factor authentication disabled"
    });
  } catch (error) {
    console.error("Error disabling 2FA:", error);
    return res.status(500).json({ 
      error: "Failed to disable 2FA", 
      message: "Your session may have expired. Please refresh the page and try again.",
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// Admin: Disable 2FA for a user
router.post('/api/admin/2fa/disable/:userId', requireAuthentication, requireAdminAccess, async (req: Request, res: Response) => {
  try {
    const userId = parseInt(req.params.userId);
    
    if (isNaN(userId)) {
      return res.status(400).json({ error: "Invalid user ID" });
    }

    // Get the user
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    });

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Disable 2FA for the user
    await db.update(users)
      .set({ 
        twoFactorEnabled: false,
        twoFactorSecret: null,
        twoFactorBackupCodes: null,
        twoFactorMethod: null
      })
      .where(eq(users.id, userId));

    return res.json({
      success: true,
      message: `Two-factor authentication disabled for user ${userId}`
    });
  } catch (error) {
    console.error("Error disabling 2FA as admin:", error);
    return res.status(500).json({ error: "Failed to disable 2FA" });
  }
});

// Get 2FA status
router.get('/status', requireAuthentication, async (req: Request, res: Response) => {
  try {
    // Add extra debugging for session
    console.log(`2FA Status - Session Info: ${req.sessionID ? `Session exists, ID: ${req.sessionID}` : 'No session ID found'}`);
    console.log(`2FA Status - Is Authenticated: ${req.isAuthenticated()}`);
    console.log(`2FA Status - User in request: ${req.user ? JSON.stringify({id: req.user.id, username: req.user.username}) : 'No user in request'}`);
    
    const userId = req.user?.id;
    
    if (!userId) {
      console.error("2FA Status - User ID not found in session");
      return res.status(401).json({ 
        error: "Unauthorized", 
        message: "Your session may have expired. Please refresh the page and try again.",
        details: "No user ID found in the session"
      });
    }

    console.log(`2FA Status requested for user: ${userId}`);

    // Get the user
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    });

    if (!user) {
      return res.status(404).json({ 
        error: "User not found",
        message: "The specified user could not be found. Please try logging in again."
      });
    }

    // Calculate number of backup codes using our improved parser
    let backupCodesCount = 0;
    if (user.twoFactorBackupCodes) {
      try {
        // Use our robust parsing function
        const backupCodes = parseBackupCodes(user.twoFactorBackupCodes);
        backupCodesCount = backupCodes.length;
        console.log(`[2FA Status] Parsed ${backupCodesCount} backup codes for user ${userId}`);
      } catch (err) {
        console.error("Error parsing backup codes:", err);
      }
    }

    console.log(`2FA Status for user ${userId}: enabled=${user.twoFactorEnabled}, method=${user.twoFactorMethod}`);
    
    // Set anti-cache headers to prevent browser caching
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    res.setHeader('Surrogate-Control', 'no-store');
    
    return res.status(200).json({
      enabled: user.twoFactorEnabled || false,
      method: user.twoFactorMethod || null,
      backupCodesCount,
      userId: userId // Include userId in response for verification
    });
  } catch (error) {
    console.error("Error getting 2FA status:", error);
    return res.status(500).json({ 
      error: "Failed to get 2FA status", 
      message: "There was an error checking your 2FA status. Please refresh the page and try again.",
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// Regenerate backup codes
router.post('/backup-codes/regenerate', requireAuthentication, async (req: Request, res: Response) => {
  try {
    const userId = req.user?.id;
    
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    // Get the user
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    });

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    if (!user.twoFactorEnabled) {
      return res.status(400).json({ error: "2FA not enabled for this user" });
    }

    // Generate new backup codes
    const backupCodes = generateRandomCodes(8); // 8 backup codes

    // Update backup codes
    await db.update(users)
      .set({ twoFactorBackupCodes: JSON.stringify(backupCodes) })
      .where(eq(users.id, userId));

    return res.json({
      success: true,
      backupCodes,
      message: "Backup codes regenerated"
    });
  } catch (error) {
    console.error("Error regenerating backup codes:", error);
    return res.status(500).json({ error: "Failed to regenerate backup codes" });
  }
});